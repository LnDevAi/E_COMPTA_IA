name: üöÄ Deploy to AWS

on:
  push:
    branches: [ main ]
    paths-ignore:
      - 'docs/**'
      - '*.md'
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy'
        required: true
        default: 'prod'
        type: choice
        options:
          - prod
          - staging
          - dev

env:
  AWS_REGION: us-west-2
  PROJECT_NAME: e-compta-ia

jobs:
  # ===================================================
  # PRE-DEPLOYMENT CHECKS
  # ===================================================
  pre-deployment:
    name: üîç Pre-deployment Checks
    runs-on: ubuntu-latest
    outputs:
      should-deploy: ${{ steps.check.outputs.should-deploy }}
      environment: ${{ steps.check.outputs.environment }}
    
    steps:
      - name: üì• Checkout code
        uses: actions/checkout@v4

      - name: üîç Check deployment conditions
        id: check
        run: |
          # D√©terminer l'environnement
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            ENVIRONMENT="${{ github.event.inputs.environment }}"
          else
            ENVIRONMENT="prod"
          fi
          
          echo "environment=$ENVIRONMENT" >> $GITHUB_OUTPUT
          echo "should-deploy=true" >> $GITHUB_OUTPUT
          
          echo "üéØ Environment: $ENVIRONMENT"
          echo "‚úÖ Deployment approved"

  # ===================================================
  # INFRASTRUCTURE DEPLOYMENT
  # ===================================================
  deploy-infrastructure:
    name: üèóÔ∏è Deploy Infrastructure
    runs-on: ubuntu-latest
    needs: pre-deployment
    if: needs.pre-deployment.outputs.should-deploy == 'true'
    environment: ${{ needs.pre-deployment.outputs.environment }}
    
    outputs:
      ecr-repository: ${{ steps.terraform.outputs.ecr-repository }}
      application-url: ${{ steps.terraform.outputs.application-url }}
    
    steps:
      - name: üì• Checkout code
        uses: actions/checkout@v4

      - name: ‚öôÔ∏è Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v3
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: üîß Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.6.0
          terraform_wrapper: false

      - name: üèóÔ∏è Deploy infrastructure
        id: terraform
        working-directory: aws/terraform
        run: |
          # Cr√©er terraform.tfvars depuis les secrets
          cat > terraform.tfvars << EOF
          project_name = "${{ env.PROJECT_NAME }}"
          environment = "${{ needs.pre-deployment.outputs.environment }}"
          aws_region = "${{ env.AWS_REGION }}"
          domain_name = "${{ secrets.DOMAIN_NAME || '' }}"
          sns_email_endpoint = "${{ secrets.SNS_EMAIL || '' }}"
          fargate_cpu = ${{ vars.FARGATE_CPU || 512 }}
          fargate_memory = ${{ vars.FARGATE_MEMORY || 1024 }}
          app_count = ${{ vars.APP_COUNT || 2 }}
          db_instance_class = "${{ vars.DB_INSTANCE_CLASS || 'db.t3.micro' }}"
          EOF
          
          # Initialiser et d√©ployer
          terraform init
          terraform validate
          terraform plan -var-file="terraform.tfvars"
          terraform apply -var-file="terraform.tfvars" -auto-approve
          
          # Extraire les outputs
          ECR_REPO=$(terraform output -raw ecr_repository_url)
          APP_URL=$(terraform output -raw application_url)
          
          echo "ecr-repository=$ECR_REPO" >> $GITHUB_OUTPUT
          echo "application-url=$APP_URL" >> $GITHUB_OUTPUT
          
          echo "‚úÖ Infrastructure deployed successfully"
          echo "üì¶ ECR Repository: $ECR_REPO"
          echo "üåê Application URL: $APP_URL"

  # ===================================================
  # APPLICATION DEPLOYMENT
  # ===================================================
  deploy-application:
    name: üöÄ Deploy Application
    runs-on: ubuntu-latest
    needs: [pre-deployment, deploy-infrastructure]
    environment: ${{ needs.pre-deployment.outputs.environment }}
    
    steps:
      - name: üì• Checkout code
        uses: actions/checkout@v4

      - name: ‚öôÔ∏è Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v3
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: üê≥ Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: üîê Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: üèóÔ∏è Build and push Docker image
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          ECR_REPOSITORY: ${{ env.PROJECT_NAME }}-app
          IMAGE_TAG: ${{ github.sha }}
        run: |
          # Build et push avec multiple tags
          docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG .
          docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:latest .
          
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:latest
          
          echo "‚úÖ Docker image pushed successfully"
          echo "üè∑Ô∏è Image tags: $IMAGE_TAG, latest"

      - name: üîÑ Update ECS service
        run: |
          # Forcer le red√©ploiement du service ECS
          aws ecs update-service \
            --cluster ${{ env.PROJECT_NAME }}-cluster \
            --service ${{ env.PROJECT_NAME }}-service \
            --force-new-deployment \
            --region ${{ env.AWS_REGION }}
          
          echo "‚úÖ ECS service update triggered"

      - name: ‚è≥ Wait for deployment
        run: |
          echo "‚è≥ Waiting for ECS service to stabilize..."
          aws ecs wait services-stable \
            --cluster ${{ env.PROJECT_NAME }}-cluster \
            --services ${{ env.PROJECT_NAME }}-service \
            --region ${{ env.AWS_REGION }}
          
          echo "‚úÖ ECS service is stable"

  # ===================================================
  # POST-DEPLOYMENT VERIFICATION
  # ===================================================
  verify-deployment:
    name: ‚úÖ Verify Deployment
    runs-on: ubuntu-latest
    needs: [pre-deployment, deploy-infrastructure, deploy-application]
    
    steps:
      - name: ü©∫ Health check
        env:
          APPLICATION_URL: ${{ needs.deploy-infrastructure.outputs.application-url }}
        run: |
          echo "üîç Testing application health..."
          
          # Attendre que l'application soit accessible
          for i in {1..30}; do
            if curl -f -s "${APPLICATION_URL}/health" > /dev/null; then
              echo "‚úÖ Application is healthy and accessible"
              echo "üåê URL: $APPLICATION_URL"
              exit 0
            fi
            echo "‚è≥ Attempt $i/30 - waiting for application..."
            sleep 10
          done
          
          echo "‚ùå Application health check failed"
          exit 1

      - name: üîç Verify ECS service
        run: |
          # V√©rifier le statut du service ECS
          SERVICE_STATUS=$(aws ecs describe-services \
            --cluster ${{ env.PROJECT_NAME }}-cluster \
            --services ${{ env.PROJECT_NAME }}-service \
            --region ${{ env.AWS_REGION }} \
            --query 'services[0].status' \
            --output text)
          
          if [ "$SERVICE_STATUS" = "ACTIVE" ]; then
            echo "‚úÖ ECS service is active"
          else
            echo "‚ùå ECS service status: $SERVICE_STATUS"
            exit 1
          fi

  # ===================================================
  # POST-DEPLOYMENT ACTIONS
  # ===================================================
  post-deployment:
    name: üìã Post-deployment Actions
    runs-on: ubuntu-latest
    needs: [pre-deployment, deploy-infrastructure, verify-deployment]
    if: always() && needs.verify-deployment.result == 'success'
    
    steps:
      - name: üìä Deployment summary
        env:
          APPLICATION_URL: ${{ needs.deploy-infrastructure.outputs.application-url }}
          ENVIRONMENT: ${{ needs.pre-deployment.outputs.environment }}
        run: |
          echo "üéâ D√âPLOIEMENT R√âUSSI !"
          echo ""
          echo "üìã R√©sum√©:"
          echo "   Environment: $ENVIRONMENT"
          echo "   Application: $APPLICATION_URL"
          echo "   Region: ${{ env.AWS_REGION }}"
          echo "   Commit: ${{ github.sha }}"
          echo ""
          echo "üöÄ L'application E-COMPTA-IA est maintenant d√©ploy√©e !"

      - name: üì¢ Notify deployment
        if: ${{ secrets.SLACK_WEBHOOK_URL }}
        run: |
          curl -X POST -H 'Content-type: application/json' \
            --data "{
              \"text\": \"üöÄ E-COMPTA-IA deployed successfully!\",
              \"blocks\": [
                {
                  \"type\": \"section\",
                  \"text\": {
                    \"type\": \"mrkdwn\",
                    \"text\": \"*E-COMPTA-IA Deployment Success* ‚úÖ\n\n*Environment:* ${{ needs.pre-deployment.outputs.environment }}\n*URL:* ${{ needs.deploy-infrastructure.outputs.application-url }}\n*Commit:* \`${{ github.sha }}\`\"
                  }
                }
              ]
            }" \
            ${{ secrets.SLACK_WEBHOOK_URL }}

  # ===================================================
  # CLEANUP ON FAILURE
  # ===================================================
  cleanup-on-failure:
    name: üßπ Cleanup on Failure
    runs-on: ubuntu-latest
    needs: [pre-deployment, deploy-infrastructure, deploy-application, verify-deployment]
    if: always() && (needs.deploy-infrastructure.result == 'failure' || needs.deploy-application.result == 'failure' || needs.verify-deployment.result == 'failure')
    
    steps:
      - name: üì• Checkout code
        uses: actions/checkout@v4

      - name: ‚öôÔ∏è Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v3
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: üìù Get ECS logs
        continue-on-error: true
        run: |
          echo "üìù Retrieving ECS logs for debugging..."
          aws logs get-log-events \
            --log-group-name "/ecs/${{ env.PROJECT_NAME }}" \
            --log-stream-name "$(aws logs describe-log-streams \
              --log-group-name "/ecs/${{ env.PROJECT_NAME }}" \
              --order-by LastEventTime \
              --descending \
              --max-items 1 \
              --query 'logStreams[0].logStreamName' \
              --output text)" \
            --region ${{ env.AWS_REGION }} \
            --query 'events[*].message' \
            --output text || echo "Could not retrieve logs"

      - name: ‚ùå Deployment failed notification
        if: ${{ secrets.SLACK_WEBHOOK_URL }}
        run: |
          curl -X POST -H 'Content-type: application/json' \
            --data "{
              \"text\": \"‚ùå E-COMPTA-IA deployment failed!\",
              \"blocks\": [
                {
                  \"type\": \"section\",
                  \"text\": {
                    \"type\": \"mrkdwn\",
                    \"text\": \"*E-COMPTA-IA Deployment Failed* ‚ùå\n\n*Environment:* ${{ needs.pre-deployment.outputs.environment }}\n*Commit:* \`${{ github.sha }}\`\n*Check logs:* <${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}|View Details>\"
                  }
                }
              ]
            }" \
            ${{ secrets.SLACK_WEBHOOK_URL }}